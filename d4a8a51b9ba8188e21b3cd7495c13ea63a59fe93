{
  "comments": [
    {
      "key": {
        "uuid": "0144b839_abf62936",
        "filename": "java/src/main/java/com/google/protobuf/nano/CodedOutputByteBufferNano.java",
        "patchSetId": 3
      },
      "lineNbr": 297,
      "author": {
        "id": 1022968
      },
      "writtenOn": "2014-12-29T11:04:14Z",
      "side": 1,
      "message": "max bytes per char in UTF-8 is actually 4 bytes (the new standard) [6 bytes in old standard].\n\nhttp://en.wikipedia.org/wiki/UTF-8\n\nJava could handle Unicode U+10000 to U+10FFFF through surrogate pairs. Those chars require 4 bytes in UTF-8.\n\nI\u0027m not aware of Protocol Buffer limiting the character range to at most U+FFFF, so better not assume.",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a12ccc7b_68bb6342",
        "filename": "java/src/main/java/com/google/protobuf/nano/CodedOutputByteBufferNano.java",
        "patchSetId": 3
      },
      "lineNbr": 297,
      "author": {
        "id": 1059543
      },
      "writtenOn": "2014-12-30T02:35:06Z",
      "side": 1,
      "message": "Per java char, not per code point. All characters that take 4 bytes in UTF-8 are represented by a surrogate pair, so while they use 4 bytes of UTF-8 they\u0027re two chars in java.",
      "parentUuid": "0144b839_abf62936",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a185ac8b_86e40ee1",
        "filename": "java/src/main/java/com/google/protobuf/nano/CodedOutputByteBufferNano.java",
        "patchSetId": 3
      },
      "lineNbr": 297,
      "author": {
        "id": 1022968
      },
      "writtenOn": "2014-12-30T11:40:50Z",
      "side": 1,
      "message": "Sorry, my bad at arriving at conclusions without looking. But maybe expand the inline comment as follows and merge it with the comment at the beginning of this method:\n\nUTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()), and at most 3 times of it. Optimize for the case where we know this length results in a constant varint length - saves measuring length of the string.",
      "parentUuid": "a12ccc7b_68bb6342",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "418cf0b9_7255fe91",
        "filename": "java/src/main/java/com/google/protobuf/nano/CodedOutputByteBufferNano.java",
        "patchSetId": 3
      },
      "lineNbr": 297,
      "author": {
        "id": 1059543
      },
      "writtenOn": "2014-12-30T21:26:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a185ac8b_86e40ee1",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0144b839_ce7d4353",
        "filename": "java/src/test/java/com/google/protobuf/NanoTest.java",
        "patchSetId": 3
      },
      "lineNbr": 2321,
      "author": {
        "id": 1022968
      },
      "writtenOn": "2014-12-30T11:40:50Z",
      "side": 1,
      "message": "- not sure about whether this needs to be tested at all; it\u0027s just implementation detail.\n- but if you do want to test string encoding at this detailed level, then this test seems to be a bit inefficient (e.g. testing string lengths 1-9) and ineffective (e.g. no surrogate pair testing; no [apparent] edge case testing).\n\nI would just remove this and put blind trust in the Guava code :)",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "418cf0b9_b20786be",
        "filename": "java/src/test/java/com/google/protobuf/NanoTest.java",
        "patchSetId": 3
      },
      "lineNbr": 2321,
      "author": {
        "id": 1059543
      },
      "writtenOn": "2014-12-30T21:26:09Z",
      "side": 1,
      "message": "I added these because I have some (somewhat complex) code that manages avoiding string measurement based on length, and so I wanted to have coverage of both code paths.",
      "parentUuid": "0144b839_ce7d4353",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a185ac8b_c61ff6cd",
        "filename": "java/src/test/java/com/google/protobuf/NanoTest.java",
        "patchSetId": 3
      },
      "lineNbr": 2321,
      "author": {
        "id": 1022968
      },
      "writtenOn": "2014-12-31T11:27:32Z",
      "side": 1,
      "message": "In that case I would hard code some useful lengths instead of going through a for-loop that seems to have an arbitrary limit (1 \u003c\u003c 17) and stepping (* 11/10 + 1).\n\nHow about:\n\n// Test string serialization roundtrip using a pure-ASCII string and a Unicode\n// string of each of the following lengths. For some of them, the length varint\n// requires more bytes for the Unicode string than the ASCII string.\nint[] lengths \u003d {\n  (1 \u003c\u003c 4) - 1,  // 1 byte for ASCII and Unicode\n  (1 \u003c\u003c 7) - 1,  // 1 byte for ASCII, 2 bytes for Unicode\n  (1 \u003c\u003c 11) - 1, // 2 bytes for ASCII and Unicode\n  (1 \u003c\u003c 14) - 1, // 2 bytes for ASCII, 3 bytes for Unicode\n  (1 \u003c\u003c 17) - 1, // 3 bytes for ASCII and Unicode\n};\nfor (int length : lengths) {\n  testEncodingOfString(\u0027q\u0027, length);\n  testEncodingOfString(\u0027\\u07FF\u0027, length);\n}",
      "parentUuid": "418cf0b9_b20786be",
      "revId": "d4a8a51b9ba8188e21b3cd7495c13ea63a59fe93",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}